{"pages":[{"title":"404","text":"","path":"404/index.html","date":"11-08","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"11-08","excerpt":""}],"posts":[{"title":"分布式锁实现方式比较","text":"写这个文章的原因是在面试阿里二面的过程中被问到过如何在不同机器（jvm）之间同步变量，当时对分布式锁不是很了解，就随便打了使用序列化传递对象，其实是答非所问。后来的工作学习中接触了分布式锁的不同实现，以及了解到在分布式系统中的应用，在此做个记录。 前言 在单机程序中，我们如果要实现不同线程的变量同步，并发量不大的情况下可以使用乐观锁（unsafe的cas，sql中带版本号set操作），并发较大时可以使用悲观锁（lock，synchronize，sql中的行锁（select for update）以及表锁（串行））。对于分布式系统而言，由于已经是不同的jvm，jdk的锁方法无法起到作用，因此只能借助第三方的锁来实现两台机器中的同步操作。目前主流的分布式锁实现主要有三种，数据库存储锁，缓存数据库存储锁，zookeeper存储锁。 数据库存储锁首先要把本文的应用于变量同步的数据库存储锁所与数据库事务锁区分开来，前者是通过多应用连接同一个数据库共享资源，后者是数据库的事务隔离级别。使用数据库进行变量同步有两种方式， 数据库锁竞争一种是在数据中显示地表达出某资源的持有人是谁，其他竞争者轮询这条记录，等待持有人使用资源完成任务后释放锁（更新记录，比如ower_id设为null），再进行锁竞争。resource_id|owner_id–|:–:1|2| 在事务中锁定数据这种同步方式和数据库事务锁有关，在数据库设置中将隔离级别设为repeatable-read，在事务中使用select for update语句后可以保证当前事务更新过程中其他事务无法更新同一列数据，可以用于不同机器中的变量累加计数。 使用数据库锁的优势与劣势 掌握数据库是编程的基本技能之一，所以使用数据库来同步变量对于开发者而言实现简单，不用依赖其他中间件，开发者也会信赖从数据库层面保证的一致性。 由于数据库是使用文件存储，变量同步的过程除了网络消耗，还有磁盘io的消耗，因此对于高频率同步的变量（比如秒杀，累加），同步消耗很会成为一个瓶颈，这种场景一般使用下一段提到的缓存数据库锁 //TODU 缓存数据库存储锁zookeeper实现的分布式锁","path":"2018/11/27/分布式锁实现方式比较/","date":"11-27","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/11/08/hello-world/","date":"11-08","excerpt":""}]}